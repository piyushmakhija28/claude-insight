#!/usr/bin/env python3
"""
Script Name: clear-session-handler.py
Version: 3.0.0 (Multi-Window Isolation)
Last Modified: 2026-02-24
Description: Detects /clear command usage via UserPromptSubmit hook.
             Compares current transcript message count vs last known count.
             If count decreased or transcript changed = /clear was used.
             Action: Save old session, create new one.

             MULTI-WINDOW FIX: Each window gets isolated state file (PID-based)
             to prevent conflicts across multiple Claude Code instances.

Detection Logic:
  - Tracks transcript_path + message count in ~/.claude/.hook-state-{PID}.json (WINDOW-SPECIFIC)
  - If msg_count < last_msg_count  -> /clear detected (count dropped)
  - If transcript_path changed     -> new conversation/window detected
  - If msg_count == 0 + no prior   -> fresh start

Voice: Writes .session-start-voice flag for stop-notifier.py to speak.
       Does NOT speak directly - single voice pipeline via stop-notifier.

Windows-Safe: No Unicode chars (ASCII only, cp1252 compatible)
"""

import sys
import os
import json
import subprocess
from pathlib import Path
from datetime import datetime

# Windows: ASCII-only output (no Unicode/emojis)
if sys.platform == 'win32':
    import io
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8', errors='replace')
    sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8', errors='replace')

MEMORY_BASE = Path.home() / '.claude' / 'memory'
CURRENT_DIR = MEMORY_BASE / 'current'
SESSIONS_DIR = MEMORY_BASE / 'sessions'
CURRENT_SESSION_FILE = MEMORY_BASE / '.current-session.json'
# MULTI-WINDOW FIX: Get window-specific hook state file via isolator
HOOK_STATE_FILE = None  # Initialized in _init_window_isolation()
CLEAR_LOG = MEMORY_BASE / 'logs' / 'clear-events.log'
SESSION_START_VOICE_FLAG = Path.home() / '.claude' / '.session-start-voice'
# Flag directory for session-specific enforcement flags (Loophole #11 fix)
FLAG_DIR = Path.home() / '.claude'


# =============================================================================
# WINDOW ISOLATION (Multi-Window Fix)
# =============================================================================

def _init_window_isolation():
    """Initialize window/PID-specific isolation."""
    global HOOK_STATE_FILE
    try:
        # Import from session-window-isolator
        from session_window_isolator import get_window_state_file, register_window
        HOOK_STATE_FILE = get_window_state_file()
        # Register this window for lifecycle tracking
        register_window('session-unknown')  # Will be updated after session is known
        log_event(f"[INIT] Window isolation active: PID={os.getpid()}, state_file={HOOK_STATE_FILE.name}")
    except ImportError:
        # Fallback if isolator not available (backwards compatibility)
        HOOK_STATE_FILE = Path.home() / '.claude' / '.hook-state.json'
        log_event(f"[WARN] session-window-isolator not found, using shared state: {HOOK_STATE_FILE}")


# =============================================================================
# LOGGING
# =============================================================================

def log_event(msg):
    """Log to clear-events.log (ASCII only)"""
    CLEAR_LOG.parent.mkdir(parents=True, exist_ok=True)
    ts = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    try:
        with open(CLEAR_LOG, 'a', encoding='utf-8') as f:
            f.write(f"{ts} | {msg}\n")
    except Exception:
        pass


# =============================================================================
# HOOK STDIN
# =============================================================================

def read_hook_stdin():
    """Read JSON data from Claude Code hook stdin"""
    try:
        if not sys.stdin.isatty():
            raw = sys.stdin.read()
            if raw and raw.strip():
                return json.loads(raw.strip())
    except Exception:
        pass
    return {}


# =============================================================================
# TRANSCRIPT ANALYSIS
# =============================================================================

def count_transcript_messages(transcript_path):
    """
    Count user+assistant messages in transcript file.
    Returns:
      -1  = cannot read / unknown state
       0  = file empty or doesn't exist (fresh conversation)
      N>0 = N messages found
    """
    if not transcript_path:
        return -1

    path = Path(transcript_path)

    if not path.exists():
        return 0  # No file = definitely fresh

    try:
        content = path.read_text(encoding='utf-8', errors='replace').strip()
        if not content:
            return 0  # Empty file = fresh

        count = 0

        # Try JSONL format (one JSON object per line) - Claude Code default
        for line in content.splitlines():
            line = line.strip()
            if not line:
                continue
            try:
                msg = json.loads(line)
                if isinstance(msg, dict):
                    role = msg.get('role', '') or msg.get('type', '')
                    if role in ('user', 'assistant', 'human'):
                        count += 1
            except Exception:
                pass

        if count > 0:
            return count

        # Try single JSON array
        try:
            data = json.loads(content)
            if isinstance(data, list):
                return len([m for m in data
                            if isinstance(m, dict)
                            and m.get('role') in ('user', 'assistant', 'human')])
            if isinstance(data, dict):
                msgs = data.get('messages', data.get('conversation', []))
                return len([m for m in msgs
                            if isinstance(m, dict)
                            and m.get('role') in ('user', 'assistant', 'human')])
        except Exception:
            pass

        # File exists and has content but can't parse = assume has messages
        return 99

    except Exception:
        return -1


# =============================================================================
# STATE TRACKING
# =============================================================================

def read_state():
    """Read the hook state file"""
    if not HOOK_STATE_FILE.exists():
        return {}
    try:
        with open(HOOK_STATE_FILE, 'r', encoding='utf-8') as f:
            return json.load(f)
    except Exception:
        return {}


def write_state(transcript_path, msg_count):
    """Update hook state with current values"""
    state = {
        'last_transcript_path': str(transcript_path) if transcript_path else '',
        'last_msg_count': msg_count,
        'updated_at': datetime.now().isoformat()
    }
    try:
        HOOK_STATE_FILE.parent.mkdir(parents=True, exist_ok=True)
        with open(HOOK_STATE_FILE, 'w', encoding='utf-8') as f:
            json.dump(state, f, indent=2)
    except Exception:
        pass


def detect_clear(current_transcript_path, current_msg_count):
    """
    Compare current state vs last state to detect /clear.
    Returns (is_fresh, reason_string)
    """
    state = read_state()
    last_transcript = state.get('last_transcript_path', '')
    last_count = state.get('last_msg_count', -1)

    # Case 1: No previous state at all - fresh start
    if not last_transcript and current_msg_count <= 1:
        return True, 'first_ever_conversation'

    # Case 2: Transcript file changed - new conversation/window
    if (last_transcript
            and current_transcript_path
            and str(current_transcript_path) != last_transcript):
        return True, f'transcript_changed_from_{Path(last_transcript).name}_to_{Path(str(current_transcript_path)).name}'

    # Case 3: Message count dropped - /clear was used
    if (last_count != -1
            and current_msg_count != -1
            and current_msg_count < last_count):
        return True, f'msg_count_dropped_from_{last_count}_to_{current_msg_count}'

    # Case 4: Transcript empty with same path - cleared
    if (last_transcript
            and current_transcript_path
            and str(current_transcript_path) == last_transcript
            and current_msg_count == 0
            and last_count > 0):
        return True, f'transcript_emptied_was_{last_count}_now_0'

    return False, 'ongoing_conversation'


# =============================================================================
# SESSION MANAGEMENT
# =============================================================================

def get_current_session_id():
    """Get active session ID from .current-session.json"""
    if not CURRENT_SESSION_FILE.exists():
        return None
    try:
        with open(CURRENT_SESSION_FILE, 'r', encoding='utf-8') as f:
            data = json.load(f)
            return data.get('current_session_id')
    except Exception:
        return None


def close_current_session(session_id):
    """Mark session as COMPLETED and remove the current session marker"""
    if not session_id:
        return False

    # Update session JSON file with end time
    session_file = SESSIONS_DIR / f'{session_id}.json'
    if session_file.exists():
        try:
            with open(session_file, 'r', encoding='utf-8') as f:
                data = json.load(f)

            data['end_time'] = datetime.now().isoformat()
            data['status'] = 'COMPLETED'
            data['closed_reason'] = 'clear_command_detected_by_hook'

            with open(session_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2)

            log_event(f"Session closed and saved: {session_id}")
        except Exception as e:
            log_event(f"Error updating session file {session_id}: {e}")

    # Delete .current-session.json so 3-level-flow creates a fresh session
    if CURRENT_SESSION_FILE.exists():
        try:
            CURRENT_SESSION_FILE.unlink()
            log_event(f"Removed .current-session.json (cleared for {session_id})")
        except Exception as e:
            log_event(f"Error removing current session file: {e}")

    return True


def write_voice_flag(message):
    """
    Write .session-start-voice flag for stop-notifier.py to pick up.
    Single voice pipeline: flag -> stop-notifier -> voice-notifier -> audio.
    """
    try:
        SESSION_START_VOICE_FLAG.write_text(message, encoding='utf-8')
        log_event(f"[voice] Flag written for stop-notifier: {message[:60]}")
    except Exception as e:
        log_event(f"[voice] Failed to write voice flag: {e}")


def get_previous_session_context(session_id):
    """
    Read the previous session's flow-trace.json to build a context summary.
    Printed to stdout so Claude sees it on the first message after /clear.
    Returns formatted string or None if no data available.
    """
    if not session_id:
        return None

    logs_dir = MEMORY_BASE / 'logs' / 'sessions' / session_id
    flow_trace = logs_dir / 'flow-trace.json'

    if not flow_trace.exists():
        log_event(f"No flow-trace found for session {session_id} at {flow_trace}")
        return None

    try:
        with open(flow_trace, 'r', encoding='utf-8') as f:
            data = json.load(f)

        user_input = data.get('user_input', {})
        final_decision = data.get('final_decision', {})
        meta = data.get('meta', {})

        prompt = user_input.get('prompt', 'Unknown')
        task_type = final_decision.get('task_type', 'Unknown')
        skill = final_decision.get('skill_or_agent', 'Unknown')
        complexity = final_decision.get('complexity', '?')
        model = final_decision.get('model_selected', 'Unknown')
        started_at = meta.get('flow_start', '')[:19].replace('T', ' ')

        # Truncate long prompts
        if len(prompt) > 300:
            prompt = prompt[:300] + '...'

        lines = [
            '',
            '[PREVIOUS SESSION CONTEXT - AUTO-LOADED AFTER /clear]',
            '=' * 65,
            f'Session ID  : {session_id}',
            f'Started At  : {started_at}',
            f'Task Type   : {task_type} (Complexity: {complexity})',
            f'Skill/Agent : {skill}',
            f'Model Used  : {model}',
            f'Last Prompt : {prompt}',
            '=' * 65,
            '[CONTINUITY] Resume work from where the previous session left off.',
            '[CONTINUITY] The user did /clear but you can reference this context.',
            '',
        ]

        log_event(f"Previous session context loaded for {session_id}")
        return '\n'.join(lines)

    except Exception as e:
        log_event(f"Error reading previous session context: {e}")
        return None


def create_new_session(reason=''):
    """Create a brand new session via session-id-generator.py"""
    sess_script = CURRENT_DIR / 'session-id-generator.py'
    if not sess_script.exists():
        log_event(f"ERROR: session-id-generator.py not found at {sess_script}")
        return None

    desc = f"New session after /clear at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
    if reason:
        desc += f" ({reason})"

    try:
        result = subprocess.run(
            [sys.executable, str(sess_script), 'create', '--description', desc],
            capture_output=True, text=True,
            encoding='utf-8', errors='replace', timeout=15
        )

        new_session_id = None
        for line in result.stdout.splitlines():
            line = line.strip()
            if line.startswith('SESSION-'):
                new_session_id = line
                break

        if new_session_id:
            log_event(f"New session created: {new_session_id} (reason: {reason})")
            # Reset session-progress.json so context % starts fresh for new session
            _reset_session_progress(new_session_id)
            return new_session_id
        else:
            log_event(f"ERROR: Could not parse session ID from output: {result.stdout[:200]}")
            return None

    except Exception as e:
        log_event(f"ERROR creating session: {e}")
        return None


def _reset_session_progress(new_session_id=''):
    """
    Reset session-progress.json when a new session starts.
    This ensures context % estimate starts from 0 (fresh session)
    instead of accumulating from previous sessions.
    """
    session_progress_file = MEMORY_BASE / 'logs' / 'session-progress.json'
    try:
        fresh = {
            'total_progress': 0,
            'tool_counts': {},
            'content_chars': 0,
            'started_at': datetime.now().strftime('%Y-%m-%dT%H:%M:%S'),
            'tasks_completed': 0,
            'errors_seen': 0,
            'context_estimate_pct': 15,
            'session_id': new_session_id,
            'reset_reason': 'new session after /clear'
        }
        session_progress_file.parent.mkdir(parents=True, exist_ok=True)
        with open(session_progress_file, 'w', encoding='utf-8') as f:
            import json as _json
            _json.dump(fresh, f, indent=2)
        log_event(f"session-progress.json reset for new session {new_session_id}")
    except Exception as e:
        log_event(f"WARNING: Could not reset session-progress.json: {e}")


# =============================================================================
# SESSION CHAINING
# =============================================================================

def _finalize_session_summary(session_id):
    """
    Finalize session summary (generate session-summary.md) before closing.
    Called by clear-session-handler on /clear.
    """
    summary_script = CURRENT_DIR / 'session-summary-manager.py'
    if not summary_script.exists():
        log_event(f"[WARN] session-summary-manager.py not found, skipping finalize")
        return

    try:
        result = subprocess.run(
            [sys.executable, str(summary_script), 'finalize',
             '--session', session_id],
            capture_output=True, text=True,
            encoding='utf-8', errors='replace', timeout=10
        )
        if result.returncode == 0:
            log_event(f"[SUMMARY] Finalized for {session_id}")
        else:
            log_event(f"[SUMMARY WARN] Finalize failed: {result.stderr[:100]}")
    except Exception as e:
        log_event(f"[SUMMARY ERROR] {e}")


def _link_session_chain(child_session, parent_session):
    """
    Link new session to its parent via session-chain-manager.py.
    Called after /clear creates a new session.
    """
    chain_script = CURRENT_DIR / 'session-chain-manager.py'
    if not chain_script.exists():
        log_event(f"[WARN] session-chain-manager.py not found, skipping chain link")
        return

    try:
        result = subprocess.run(
            [sys.executable, str(chain_script), 'link',
             '--child', child_session, '--parent', parent_session],
            capture_output=True, text=True,
            encoding='utf-8', errors='replace', timeout=10
        )
        if result.returncode == 0:
            log_event(f"[CHAIN] Linked {child_session} -> parent: {parent_session}")
        else:
            log_event(f"[CHAIN WARN] Link failed: {result.stderr[:100]}")
    except Exception as e:
        log_event(f"[CHAIN ERROR] {e}")


# =============================================================================
# MAIN
# =============================================================================

def main():
    # Initialize window isolation (PID-based state files)
    _init_window_isolation()

    # INTEGRATION: Load session management policies from scripts/architecture/
    try:
        script_dir = Path(__file__).parent
        session_loader = script_dir / 'architecture' / '01-sync-system' / 'session-management' / 'session-loader.py'
        if session_loader.exists():
            subprocess.run([sys.executable, str(session_loader)], timeout=3, capture_output=True)
    except:
        pass  # Policy execution is optional

    hook_data = read_hook_stdin()

    transcript_path = hook_data.get('transcript_path', '')
    prompt = hook_data.get('prompt', '')
    prompt_preview = prompt[:80].replace('\n', ' ')

    # Count messages in current transcript
    current_msg_count = count_transcript_messages(transcript_path)

    log_event(
        f"Hook fired | msg_count={current_msg_count} | "
        f"transcript={transcript_path} | prompt='{prompt_preview}'"
    )

    # If we can't determine state at all, skip
    if current_msg_count == -1 and not transcript_path:
        log_event("Cannot determine conversation state - skipping")
        # Still update state with what we know
        write_state(transcript_path, current_msg_count)
        sys.exit(0)

    # Detect if this is a fresh conversation
    is_fresh, reason = detect_clear(transcript_path, current_msg_count)

    if is_fresh:
        log_event(f"[CLEAR DETECTED] reason={reason}")

        current_session = get_current_session_id()

        if current_session:
            # Load previous session context BEFORE closing (reads flow-trace.json)
            prev_context = get_previous_session_context(current_session)

            # Finalize session summary BEFORE closing
            _finalize_session_summary(current_session)

            # Save and close the old session
            print(f"[SESSION] /clear detected - saving: {current_session}")
            close_current_session(current_session)
            print(f"[SESSION] Old session saved: {current_session}")

            # Print previous context AFTER session markers so Claude sees it clearly
            if prev_context:
                print(prev_context)

            # Clear ALL enforcement flags from ALL sessions - /clear = fresh start
            # Loophole #11: flags are now session-specific, use glob to find all
            import glob as _glob
            for pattern, flag_name in [
                ('.checkpoint-pending-*.json', 'Checkpoint'),
                ('.task-breakdown-pending-*.json', 'Task-breakdown'),
                ('.skill-selection-pending-*.json', 'Skill-selection'),
            ]:
                for flag_file in _glob.glob(str(FLAG_DIR / pattern)):
                    try:
                        Path(flag_file).unlink()
                        log_event(f"{flag_name} flag cleared on /clear: {Path(flag_file).name}")
                    except Exception:
                        pass

            # Create fresh session
            new_session = create_new_session(reason=reason)
            if new_session:
                print(f"[SESSION] New session started: {new_session}")
                log_event(f"Session transition complete: {current_session} -> {new_session}")

                # Chain link: new session -> parent (old session)
                _link_session_chain(new_session, current_session)
                # Voice: English, professional boss-assistant style
                import random
                hour = datetime.now().hour
                if hour < 12:
                    greet = 'Good morning'
                elif hour < 17:
                    greet = 'Good afternoon'
                else:
                    greet = 'Good evening'
                clear_messages = [
                    f"{greet} Sir. Session cleared and refreshed. Ready for your next task.",
                    f"{greet} Sir. Fresh session started. What would you like to work on?",
                    f"{greet} Sir. Previous session saved. I am ready for new commands.",
                    f"{greet} Sir. Session reset complete. Let me know what you need.",
                ]
                write_voice_flag(random.choice(clear_messages))
            else:
                print(f"[SESSION] Warning: Could not create new session")
                log_event("Warning: Failed to create new session after /clear")
        else:
            # No existing session - just create a new one
            # (3-level-flow will also try to create if none exists, but we do it here
            #  so it's ready before 3-level-flow reads it)
            new_session = create_new_session(reason=reason)
            if new_session:
                print(f"[SESSION] First session created: {new_session}")
                # Voice: first session - professional welcome
                import random
                hour = datetime.now().hour
                if hour < 12:
                    greet = 'Good morning'
                elif hour < 17:
                    greet = 'Good afternoon'
                else:
                    greet = 'Good evening'
                first_messages = [
                    f"{greet} Sir. First session started. I am ready to assist you.",
                    f"{greet} Sir. Welcome. Tell me what you would like to work on today.",
                    f"{greet} Sir. New session initialized. Ready for your commands.",
                ]
                write_voice_flag(random.choice(first_messages))

    else:
        log_event(f"Ongoing conversation ({reason}) - no session change")

    # Always update state with current values for next call comparison
    write_state(transcript_path, current_msg_count)

    # Cleanup window state on exit
    try:
        from session_window_isolator import cleanup_window
        cleanup_window()
    except Exception:
        pass

    sys.exit(0)


if __name__ == '__main__':
    main()
